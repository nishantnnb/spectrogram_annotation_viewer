<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spectrogram Viewer</title>
  <style>
    :root{
      --bg:#111; --panel:#0b0b0b; --muted:#888; --headerStart:#161616; --headerEnd:#0e0e0e;
      --white:#ddd; --accent:#4ea1ff; --select-bg:#f6f8fa; --select-fg:#111;
    }
    body { font-family: system-ui, Arial; margin: 12px; color:var(--white); background:var(--bg); }
    #controls { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:10px; font-size:13px; }
    .ctrl-label { color:var(--white); font-size:13px; display:inline-flex; gap:6px; align-items:center; white-space:normal; max-width:360px; }
    input[type="range"] { vertical-align:middle; }
    button { padding:6px 10px; font-size:13px; }
    .small { font-size:12px; color:var(--muted); margin-left:6px; }
    canvas { background:#000; display:block; border:1px solid #333; }
    #viewer { width:100%; }
    #annTableContainer { margin-top:12px; color:var(--white); background:var(--panel); border:1px solid #262626; padding:8px; border-radius:6px; }
    .resizable-wrap { display:block; width:100%; overflow:auto; max-height:420px; }
    #annSelectRow { display:flex; gap:6px; align-items:center; margin-bottom:8px; flex-wrap:nowrap; font-size:12px; }
    .compact-select-wrap { display:flex; align-items:center; gap:6px; margin:0; }
    .compact-label { font-size:12px; color:var(--white); margin-right:4px; display:inline-block; min-width:66px; text-align:right; }
    .compact-select { background:var(--select-bg); color:var(--select-fg); border:1px solid #cfd8e3; padding:5px 8px; font-size:12px; border-radius:4px; min-width:80px; -webkit-appearance:none; appearance:none; }
    .compact-select:disabled { background:#e9ecef; color:#666; }
    .resizable-table { width:100%; border-collapse:collapse; table-layout:fixed; font-size:13px; }
    .resizable-table thead th {
      position:relative; background: linear-gradient(180deg, var(--headerStart), var(--headerEnd)); color:var(--white);
      padding:6px 8px; border-bottom:2px solid #2b2b2b; font-weight:700; text-align:left; user-select:none; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-size:12px; line-height:1.1;
    }
    .resizable-table tbody td {
      padding:4px 8px; border-bottom:1px solid #1a1a1a; font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; color:var(--white);
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); line-height:1.1;
    }
    .resizable-table tbody input[type="text"]{ height:26px; font-size:12px; padding:4px; width:100%; box-sizing:border-box; background:#111; color:var(--white); border:1px solid #333; border-radius:3px; }
    .col-resizer { position:absolute; right:0; top:0; width:10px; height:100%; cursor:col-resize; z-index:10; touch-action:none; }
    .col-resizer::after{ content:''; position:absolute; top:12px; bottom:12px; left:4px; width:2px; background: rgba(255,255,255,0.06); border-radius:2px; }
    .resizable-table thead th:hover { background: linear-gradient(180deg, #252525, #151515); }
    .disabled { opacity:0.5; pointer-events:none; }
    #annSelectRow .compact-select-wrap { min-width:0; margin-right:4px; }
    #annSelectRow .compact-select { min-width:80px; padding:4px 6px; font-size:12px; }
    #annSelectRow label { margin:0; }
    #annSelectRow input[type="checkbox"]{ transform:scale(1.05); margin-right:4px; }
    .play-checkbox { width:16px; height:16px; cursor:pointer; }
    tr.annotation-selected { background: linear-gradient(90deg, rgba(78,161,255,0.14), rgba(78,161,255,0.06)); }
    @media (max-width:900px){ #annSelectRow { flex-wrap:wrap; } }
    @media (max-width:420px){ #annSelectRow .compact-select { width:120px; max-width:100%; } }
  </style>
</head>
<body>
  <div id="controls">
   <div>
    <label style="display:inline-flex; align-items:center; gap:6px;">
      <strong style="font-size:13px; color:var(--white);">Sound file</strong>
      <input id="file" type="file" accept="audio/*" />
    </label>

    <label style="display:inline-flex; align-items:center; gap:6px;">
      <strong style="font-size:13px; color:var(--white);">Annotation</strong>
      <input id="annFile" type="file" accept=".csv,.tsv,.txt" />
    </label>

    <button id="playFromStart">Play from start</button>
    <button id="playToggle">Resume</button>
    <button id="stop">Stop</button>

    <label class="ctrl-label">
      <strong>FFT</strong>
      <select id="fft">
        <option value="512">512</option>
        <option value="1024">1024</option>
        <option value="2048" selected>2048</option>
        <option value="4096">4096</option>
      </select>
    </label>

    <label class="ctrl-label">
      <strong>Palette</strong>
      <select id="palette">
        <option value="heat" selected>heat</option>
        <option value="viridis">viridis</option>
        <option value="magma">magma</option>
        <option value="bw">bw</option>
        <option value="cyan">cyan</option>
      </select>
    </label>
   </div>

   <div>
    <label class="ctrl-label">
      <strong>Zoom</strong>
      <input id="speed" type="range" min="1" max="8" step="1" value="1" />
    </label>

    <label class="ctrl-label">
      <strong>Y max (kHz)</strong>
      <input id="yMax" type="range" min="0" max="24" step="0.1" value="15" style="width:160px" />
      <span id="yMaxLabel" class="small">15.0</span>
    </label>

    <label class="ctrl-label" style="align-items:center;">
      <strong>Canvas width</strong>
      <select id="canvasWidthPreset" class="compact-select" style="margin-left:8px;">
        <option value="600">600</option>
        <option value="900">900</option>
        <option value="1200">1200</option>
        <option value="1400" selected>1400</option>
        <option value="1800">1800</option>
        <option value="100%">Full</option>
        <option value="custom">Custom</option>
      </select>
      <input id="canvasWidthCustom" type="number" min="200" step="50" placeholder="px" style="width:84px; display:none; margin-left:8px;" />
      <span id="canvasWidthInfo" class="small" style="margin-left:8px">1400px</span>
    </label>
   </div>
  </div>

  <div id="viewer">
    <canvas id="canvas" width="1400" height="400"></canvas>
  </div>

  <div id="annTableContainer" aria-live="polite">
    <div id="annSelectRow" title="Select columns">
      <div class="compact-select-wrap" style="align-items:center;">
        <input id="boxType" type="checkbox" checked />
        <label class="compact-label" for="boxType" style="text-align:left; min-width:48px;">Box type</label>
      </div>

      <div class="compact-select-wrap">
        <label class="compact-label" for="annSelectStart">Start Time</label>
        <select id="annSelectStart" class="compact-select" aria-label="Start column"></select>
      </div>

      <div class="compact-select-wrap">
        <label class="compact-label" for="annSelectEnd">End Time</label>
        <select id="annSelectEnd" class="compact-select" aria-label="End column"></select>
      </div>

      <div class="compact-select-wrap">
        <label class="compact-label" for="annSelectLow">Low Freq</label>
        <select id="annSelectLow" class="compact-select" aria-label="Low Freq column"></select>
      </div>

      <div class="compact-select-wrap">
        <label class="compact-label" for="annSelectHigh">High Freq</label>
        <select id="annSelectHigh" class="compact-select" aria-label="High Freq column"></select>
      </div>

      <div class="compact-select-wrap">
        <label class="compact-label" for="annSelectLabel">Label</label>
        <select id="annSelectLabel" class="compact-select" aria-label="Label column"></select>
      </div>

      <div style="margin-left:auto; color:#bbb; font-size:13px; display:flex; align-items:center; gap:8px;">
        <strong>Position</strong>
        <span id="pos" style="min-width:76px; text-align:right; display:inline-block;">0.00</span>s
      </div>
    </div>

    <div class="resizable-wrap">
      <table id="annTable" class="resizable-table" style="display:none">
        <thead><tr id="annHeaderRow"></tr></thead>
        <tbody id="annBody"></tbody>
      </table>
    </div>
  </div>

  <script>
  (function(){
    const DEFAULT_COLUMN_WIDTH_PX = 80;
    let GLOBAL_lastParsedAnnotation = null;
    let __spectro_currentAnnotationIndex = -1;
    let __spectro_annotationStopTimer = null;
    let lastAnnotationFilename = '';
    let __spectro_inSnippetPlayback = false;

    const UI = (function(){
      const elements = {
        fileIn: document.getElementById('file'),
        annFile: document.getElementById('annFile'),
        playToggle: document.getElementById('playToggle'),
        playFromStart: document.getElementById('playFromStart'),
        stop: document.getElementById('stop'),
        fft: document.getElementById('fft'),
        speed: document.getElementById('speed'),
        palette: document.getElementById('palette'),
        posLabel: document.getElementById('pos'),
        canvas: document.getElementById('canvas'),
        yMax: document.getElementById('yMax'),
        yMaxLabel: document.getElementById('yMaxLabel'),
        annTable: document.getElementById('annTable'),
        annHeaderRow: document.getElementById('annHeaderRow'),
        annBody: document.getElementById('annBody'),
        annSelectRow: document.getElementById('annSelectRow'),
        annSelectStart: document.getElementById('annSelectStart'),
        annSelectEnd: document.getElementById('annSelectEnd'),
        annSelectLow: document.getElementById('annSelectLow'),
        annSelectHigh: document.getElementById('annSelectHigh'),
        annSelectLabel: document.getElementById('annSelectLabel'),
        boxType: document.getElementById('boxType'),
        canvasWidthPreset: document.getElementById('canvasWidthPreset'),
        canvasWidthCustom: document.getElementById('canvasWidthCustom'),
        canvasWidthInfo: document.getElementById('canvasWidthInfo'),
      };
      let handlers = {};
      function safeCall(fn, ...args){ if(typeof fn==='function') try{ fn(...args); }catch(e){ console.error('UI handler error', e); } }
      if (elements.fileIn) elements.fileIn.addEventListener('change', (e)=> safeCall(handlers.onFile, e));
      if (elements.annFile) elements.annFile.addEventListener('change', (e)=> safeCall(handlers.onAnnFile, e));
      if (elements.playToggle) elements.playToggle.addEventListener('click', (e)=> safeCall(handlers.onPlayToggle, e));
      if (elements.playFromStart) elements.playFromStart.addEventListener('click', (e)=> safeCall(handlers.onPlayFromStart, e));
      if (elements.stop) elements.stop.addEventListener('click', (e)=> safeCall(handlers.onStop, e));
      if (elements.fft) elements.fft.addEventListener('change', (e)=> safeCall(handlers.onFFT, e));
      if (elements.palette) elements.palette.addEventListener('change', (e)=> safeCall(handlers.onPalette, e));
      if (elements.speed) elements.speed.addEventListener('input', (e)=> safeCall(handlers.onSpeed, e));
      if (elements.yMax) elements.yMax.addEventListener('input', (e)=>{
        if(elements.yMaxLabel) elements.yMaxLabel.textContent = Number(elements.yMax.value).toFixed(1);
        safeCall(handlers.onYMax, e);
      });
      ['annSelectStart','annSelectEnd','annSelectLow','annSelectHigh','annSelectLabel'].forEach(id=>{
        const el = elements[id];
        if(el) el.addEventListener('change', ()=> safeCall(handlers.onMappingChange));
      });
      if(elements.boxType) elements.boxType.addEventListener('change', ()=> safeCall(handlers.onMappingChange));
      return {
        elements,
        onFile(fn){ handlers.onFile = fn; },
        onAnnFile(fn){ handlers.onAnnFile = fn; },
        onPlayToggle(fn){ handlers.onPlayToggle = fn; },
        onPlayFromStart(fn){ handlers.onPlayFromStart = fn; },
        onStop(fn){ handlers.onStop = fn; },
        onFFT(fn){ handlers.onFFT = fn; },
        onPalette(fn){ handlers.onPalette = fn; },
        onSpeed(fn){ handlers.onSpeed = fn; },
        onYMax(fn){ handlers.onYMax = fn; },
        onMappingChange(fn){ handlers.onMappingChange = fn; },
        setPlayEnabled(enabled){ if (elements.playToggle) elements.playToggle.disabled = !enabled; if (elements.playFromStart) elements.playFromStart.disabled = !enabled; },
        setStopEnabled(enabled){ if (elements.stop) elements.stop.disabled = !enabled; },
        setPlayText(text){ if (elements.playToggle) elements.playToggle.textContent = text; },
        setPositionText(cur){
          try{
            let curSec = 0;
            if (typeof cur === 'number' && Number.isFinite(cur)) curSec = cur;
            else if (typeof cur === 'string' && cur.length) { const parsed = parseFloat(cur); curSec = Number.isFinite(parsed) ? parsed : 0; }
            else curSec = 0;
            let total = 0;
            try{
              const buf = (typeof Audio !== 'undefined' && Audio && typeof Audio.getBuffer === 'function') ? Audio.getBuffer() : null;
              if (buf && typeof buf.duration === 'number' && Number.isFinite(buf.duration)) total = buf.duration;
            }catch(e){}
            const curStr = Number.isFinite(curSec) ? curSec.toFixed(2) : '0.00';
            const totalStr = Number.isFinite(total) ? total.toFixed(2) : '0.00';
            if (elements.posLabel) elements.posLabel.textContent = `${curStr} / ${totalStr}`;
          }catch(e){
            console.error('setPositionText error', e);
            if (elements.posLabel) elements.posLabel.textContent = String(cur);
          }
        },
        getCanvasContext(options){ return elements.canvas.getContext('2d', options); },
        renderAnnotationTableFull(headers, rows){
          const tbl = elements.annTable;
          const headRow = elements.annHeaderRow;
          const body = elements.annBody;
          headRow.innerHTML = '';
          body.innerHTML = '';
          if(!headers || !headers.length){ tbl.style.display='none'; return; }

          const playTh = document.createElement('th'); playTh.textContent = 'Play'; playTh.style.minWidth='48px'; playTh.style.width='56px'; playTh.style.position='relative'; headRow.appendChild(playTh);

          const srTh = document.createElement('th'); srTh.dataset.colIndex = 0; srTh.textContent = 'Sr'; srTh.style.minWidth='24px'; srTh.style.width='64px'; srTh.style.maxWidth='64px'; srTh.style.position='relative';
          const srResizer = document.createElement('div'); srResizer.className = 'col-resizer'; srTh.appendChild(srResizer); headRow.appendChild(srTh);

          headers.forEach((h, i)=>{
            const th = document.createElement('th');
            th.dataset.colIndex = i + 1;
            th.textContent = h;
            th.style.minWidth = '24px';
            th.style.width = DEFAULT_COLUMN_WIDTH_PX + 'px';
            th.style.maxWidth = '400px';
            th.style.position = 'relative';
            const resizer = document.createElement('div'); resizer.className = 'col-resizer'; th.appendChild(resizer);
            headRow.appendChild(th);
          });

          const reviewedTh = document.createElement('th'); reviewedTh.dataset.colIndex = headers.length + 1; reviewedTh.textContent = 'Reviewed OK';
          reviewedTh.style.minWidth = '48px'; reviewedTh.style.width = '120px'; reviewedTh.style.maxWidth = '160px'; reviewedTh.style.position = 'relative';
          const revResizer = document.createElement('div'); revResizer.className = 'col-resizer'; reviewedTh.appendChild(revResizer); headRow.appendChild(reviewedTh);

          const remarksTh = document.createElement('th'); remarksTh.dataset.colIndex = headers.length + 2; remarksTh.style.minWidth = '120px'; remarksTh.style.width = '260px'; remarksTh.style.maxWidth = '520px'; remarksTh.style.position = 'relative';
          const wrapper = document.createElement('div'); wrapper.style.display='flex'; wrapper.style.alignItems='center'; wrapper.style.gap='8px'; wrapper.style.justifyContent='space-between';
          const titleSpan = document.createElement('span'); titleSpan.textContent = 'Rejection remarks'; wrapper.appendChild(titleSpan);
          const saveBtn = document.createElement('button'); saveBtn.textContent = 'Save Review'; saveBtn.style.padding='4px 8px'; saveBtn.style.fontSize='12px';
          saveBtn.addEventListener('click', function(){ try { if(typeof onSaveReviewRequest === 'function') onSaveReviewRequest(); } catch(e){ console.error(e); } });
          wrapper.appendChild(saveBtn);
          remarksTh.appendChild(wrapper);
          const remResizer = document.createElement('div'); remResizer.className = 'col-resizer'; remarksTh.appendChild(remResizer); headRow.appendChild(remarksTh);

          rows.forEach((r, rowIdx)=>{
            const tr = document.createElement('tr');

            const playTd = document.createElement('td');
            const playChk = document.createElement('input');
            playChk.type = 'checkbox';
            playChk.className = 'play-checkbox';
            playChk.dataset.rowIndex = rowIdx;
            playChk.setAttribute('aria-label', `Play row ${rowIdx+1}`);
            playChk.addEventListener('click', function(ev){
              ev.stopPropagation();
              const ri = Number(this.dataset.rowIndex);
              // restored behavior: when the play checkbox is checked, start snippet playback for that row
              // and uncheck other play checkboxes; when unchecked, stop snippet playback if it's the current snippet.
              if(this.checked){
                // uncheck other play checkboxes
                const table = UI.elements.annTable;
                Array.from(table.querySelectorAll('input.play-checkbox')).forEach(ch=>{
                  if(Number(ch.dataset.rowIndex) !== ri) ch.checked = false;
                });
                startRowSwitchPlayback(ri);
                return;
              } else {
                // unchecked
                if(__spectro_inSnippetPlayback && __spectro_currentAnnotationIndex === ri){
                  clearSnippetPlayback();
                } else {
                  __spectro_currentAnnotationIndex = -1;
                  updatePlayCheckboxStates();
                }
                return;
              }
            });
            playTd.appendChild(playChk);
            tr.appendChild(playTd);

            const srTd = document.createElement('td'); srTd.textContent = String(rowIdx + 1); srTd.style.width='64px'; srTd.style.minWidth='40px'; srTd.style.maxWidth='64px'; tr.appendChild(srTd);

            headers.forEach(h=>{
              const td = document.createElement('td');
              td.textContent = (r.hasOwnProperty(h) && r[h] !== null && r[h] !== undefined) ? String(r[h]) : '';
              td.style.overflow = 'hidden'; td.style.textOverflow = 'ellipsis'; td.style.whiteSpace = 'nowrap'; td.style.maxWidth = '400px';
              tr.appendChild(td);
            });

            const reviewedTd = document.createElement('td'); reviewedTd.style.textAlign = 'center';
            const chk = document.createElement('input'); chk.type='checkbox'; chk.checked = true; chk.dataset.rowIndex = rowIdx; reviewedTd.appendChild(chk); tr.appendChild(reviewedTd);

            const remarksTd = document.createElement('td');
            const inp = document.createElement('input'); inp.type='text'; inp.disabled = chk.checked; inp.value=''; inp.dataset.rowIndex = rowIdx; remarksTd.appendChild(inp); tr.appendChild(remarksTd);

            chk.addEventListener('change', function(){ if (this.checked) { try { inp.value = ''; } catch(e){} } inp.disabled = this.checked; });

            body.appendChild(tr);
          });

          tbl.style.display = 'table';
          initColumnResizers(tbl);
        },

        populateAnnotationSelects(headers){
          const mappings = [
            { el: elements.annSelectStart, id: 'start' },
            { el: elements.annSelectEnd, id: 'end' },
            { el: elements.annSelectLow, id: 'low' },
            { el: elements.annSelectHigh, id: 'high' },
            { el: elements.annSelectLabel, id: 'label' },
          ];
          mappings.forEach(m=>{
            const sel = m.el;
            if(!sel) return;
            const cur = sel.value || '';
            sel.innerHTML = '';
            const emptyOpt = document.createElement('option'); emptyOpt.value = ''; emptyOpt.textContent = ''; sel.appendChild(emptyOpt);
            headers.forEach(h=>{
              const o = document.createElement('option');
              o.value = h;
              o.textContent = h;
              sel.appendChild(o);
            });
            if(cur && headers.includes(cur)) sel.value = cur;
            else sel.value = '';
          });
        },

        setCanvasWidthInfo(text){ try{ if(elements.canvasWidthInfo) elements.canvasWidthInfo.textContent = text; }catch(e){} }
      };
    })();

    let onSaveReviewRequest = null;

    function paletteColor(name, v){
      const t = v / 255;
      if (name === 'bw') { const g=Math.round(255*t); return `rgb(${g},${g},${g})`; }
      if (name === 'cyan'){ const c=Math.round(255*t); return `rgb(0,${c},${Math.round(255*Math.sqrt(t))})`; }
      if (name === 'viridis'){ const r=Math.round(68+187*Math.pow(t,1.2)); const g=Math.round(1+200*t); const b=Math.round(84+100*(1-Math.pow(1-t,1.1))); return `rgb(${r},${g},${b})`; }
      if (name === 'magma'){ const r=Math.round(20+230*Math.pow(t,1.5)); const g=Math.round(5+140*Math.pow(t,1.1)); const b=Math.round(60*(1-t)); return `rgb(${r},${g},${b})`; }
      const r=Math.floor(255*Math.min(1, t*1.4));
      const g=Math.floor(255*Math.min(1, Math.max(0, (t-0.15)/0.7)));
      const b=Math.floor(255*Math.max(0, 1 - t*1.2));
      return `rgb(${r},${g},${b})`;
    }

    const Annotations = (function(){
      function parseHeader(line){
        const cols = line.split(/\t|,/).map(h=>h.trim());
        if(cols.length===1 && cols[0].includes(' ')) return cols[0].split(/\s+/).map(h=>h.trim());
        return cols;
      }
      function safeValue(s){ return s === undefined ? '' : s; }
      function parseAnnotationText(text){
        if(!text) return { headers:[], rows:[] };
        const lines = text.replace(/\r\n/g,'\n').split('\n').map(l=>l.replace(/\uFEFF/g,'').trim());
        const nonEmpty = lines.filter(l=>l.length);
        if(!nonEmpty.length) return { headers:[], rows:[] };
        const headerLine = nonEmpty[0];
        const headers = parseHeader(headerLine).slice();
        const rows = [];
        nonEmpty.slice(1).forEach(line=>{
          const cols = line.split(/\t|,/);
          const row = {};
          for(let i=0;i<cols.length;i++){
            const key = headers[i] !== undefined ? headers[i] : `col_${i+1}`;
            if(!headers.includes(key)) headers.push(key);
            row[key] = safeValue(cols[i]);
          }
          headers.forEach(h=>{ if(!row.hasOwnProperty(h)) row[h]=''; });
          rows.push(row);
        });
        return { headers, rows };
      }
      return { parseAnnotationText };
    })();

    const Audio = (function(){
      const hooks = { onPlayStart:null, onPlayPause:null, onPlayStop:null, onEnded:null };
      let audioCtx=null, gainNode=null, analyser=null, source=null, audioBuffer=null;
      let isPlaying=false, startTime=0, pausedAt=0, suppressOnEnded=false;
      function ensureAudioCtx(){ if(!audioCtx){ audioCtx=new (window.AudioContext||window.webkitAudioContext)(); gainNode=audioCtx.createGain(); gainNode.gain.value = 1; gainNode.connect(audioCtx.destination);} return audioCtx; }
      function createAnalyser(){ ensureAudioCtx(); try{ if(analyser) analyser.disconnect(); }catch(e){} analyser=audioCtx.createAnalyser(); analyser.fftSize=Number(UI.elements.fft?UI.elements.fft.value:2048); analyser.smoothingTimeConstant=0.05; return analyser; }
      function getAnalyser(createIfMissing=true){ if(!analyser && createIfMissing) createAnalyser(); return analyser; }
      async function loadArrayBuffer(arrayBuffer){ ensureAudioCtx(); try{ if(audioCtx.state==='suspended') await audioCtx.resume().catch(()=>{}); }catch(e){} try{ audioBuffer = await audioCtx.decodeAudioData(arrayBuffer); }catch(err){ audioBuffer = await new Promise((res,rej)=>audioCtx.decodeAudioData(arrayBuffer,res,rej)); } UI.setPlayEnabled(!!audioBuffer); UI.setPositionText('0.00'); return audioBuffer; }
      function internalOnEnded(){
        if(suppressOnEnded){
          suppressOnEnded=false;
          try{ if(source) source.disconnect(); }catch(e){}
          source=null; isPlaying=false; UI.setStopEnabled(false);
          if(typeof hooks.onPlayStop==='function') hooks.onPlayStop();
          try{ if(UI.elements.playFromStart) UI.elements.playFromStart.disabled=false; }catch(e){}
          UI.setPlayText('Resume');
          setCanvasWidthControlsEnabled(true);
          if(__spectro_inSnippetPlayback){
            __spectro_inSnippetPlayback = false;
            disableZoomAndYmax(false);
          }
          return;
        }
        isPlaying=false;
        if(source) try{ source.disconnect(); }catch(e){}
        source=null;
        UI.setStopEnabled(false);
        UI.setPlayText('Resume');
        try{ window.__spectro_playback_ended=true; }catch(e){}
        try{ if(typeof Draw!=='undefined' && Draw && typeof Draw.renderFinalFrame==='function') Draw.renderFinalFrame({ naturalEnd:true }); }catch(e){}
        if(typeof hooks.onEnded==='function') hooks.onEnded();
        try{ if(UI.elements.playFromStart) UI.elements.playFromStart.disabled=false; }catch(e){}
        setCanvasWidthControlsEnabled(true);
        if(__spectro_inSnippetPlayback){
          __spectro_inSnippetPlayback = false;
          disableZoomAndYmax(false);
        }
      }
      function startPlayback(offsetSec=0){
        if(!audioBuffer) throw new Error('No audio buffer loaded');
        ensureAudioCtx();
        try{ if(audioCtx.state==='suspended') audioCtx.resume().catch(()=>{}); }catch(e){}
        createAnalyser();
        try{ window.__spectro_playback_ended=false; }catch(e){}
        if(typeof Draw!=='undefined' && Draw && typeof Draw.clearLastGood==='function') Draw.clearLastGood();
        try{ window.__spectro_paused_time=null; }catch(e){}
        source=audioCtx.createBufferSource();
        source.buffer=audioBuffer;
        source.onended=internalOnEnded;
        source.connect(analyser);
        analyser.connect(gainNode);
        gainNode.gain.setValueAtTime(1, audioCtx.currentTime);
        startTime = audioCtx.currentTime - (offsetSec||0);
        source.start(0, offsetSec||0);
        isPlaying=true;
        UI.setPlayText('Pause');
        UI.setStopEnabled(true);
        if(typeof hooks.onPlayStart==='function') hooks.onPlayStart(offsetSec);
        setCanvasWidthControlsEnabled(false);
      }
      function pausePlayback(){
        if(!isPlaying || !source) return;
        try{ Draw.stopDrawLoop(); }catch(e){}
        pausedAt = (audioCtx && audioCtx.currentTime) ? (audioCtx.currentTime - startTime) : Audio.getCurrentPosition();
        try{ window.__spectro_paused_time=pausedAt; }catch(e){}
        try{ source.stop(); }catch(e){}
        source=null;
        isPlaying=false;
        UI.setPlayText('Resume');
        UI.setStopEnabled(false);
        try{ window.__spectro_playback_ended=false; }catch(e){}
        try{
          const analyserNode = Audio.getAnalyser(false);
          if(analyserNode && typeof analyserNode.getByteFrequencyData==='function'){
            const finalBytes = new Uint8Array(analyserNode.frequencyBinCount);
            try{ analyserNode.getByteFrequencyData(finalBytes); }catch(e){}
            const count = Math.max(1, Number(UI.elements.speed?UI.elements.speed.value:1));
            try{ Draw.insertFinalColumns(finalBytes, count, UI.elements.palette?UI.elements.palette.value:'heat'); }catch(e){}
          }
        }catch(e){}
        try{ Draw.renderFinalFrame({ curSecOverride: pausedAt }); }catch(e){}
        if(typeof hooks.onPlayPause==='function') hooks.onPlayPause(pausedAt);
        UI.setPositionText(pausedAt);
        setCanvasWidthControlsEnabled(true);
        if(__spectro_inSnippetPlayback){
          __spectro_inSnippetPlayback = false;
          disableZoomAndYmax(false);
        }
      }
      function stopPlaybackSilent(){
        if(source){
          try{ suppressOnEnded=true; source.stop(); }catch(e){ suppressOnEnded=false; }
        }
        source=null; isPlaying=false; pausedAt=0; UI.setPlayText('Resume'); UI.setStopEnabled(false); UI.setPositionText(0);
        try{ window.__spectro_paused_time=null; }catch(e){}
        if(typeof hooks.onPlayStop==='function') hooks.onPlayStop();
        setCanvasWidthControlsEnabled(true);
        if(__spectro_inSnippetPlayback){
          __spectro_inSnippetPlayback = false;
          disableZoomAndYmax(false);
        }
      }
      function stopPlayback(){
        if(source){
          try{ suppressOnEnded=true; source.stop(); }catch(e){ suppressOnEnded=false; }
        }
        source=null; isPlaying=false; pausedAt=0; UI.setPlayText('Resume'); UI.setStopEnabled(false); UI.setPositionText(0);
        try{ window.__spectro_paused_time=null; }catch(e){}
        if(typeof hooks.onPlayStop==='function') hooks.onPlayStop();
        try{ if(UI.elements.playFromStart) UI.elements.playFromStart.disabled=false; }catch(e){}
        setCanvasWidthControlsEnabled(true);
        if(__spectro_inSnippetPlayback){
          __spectro_inSnippetPlayback = false;
          disableZoomAndYmax(false);
        }
      }
      function getCurrentPosition(){ if(!audioCtx) return 0; return isPlaying ? (audioCtx.currentTime - startTime) : pausedAt; }
      function isPlayingNow(){ return isPlaying; }
      function getBuffer(){ return audioBuffer; }
      return { hooks, loadArrayBuffer, startPlayback, pausePlayback, stopPlayback, stopPlaybackSilent, getAnalyser, createAnalyser, getAudioContext:()=>audioCtx, getCurrentPosition, isPlayingNow, getBuffer };
    })();

    const Draw = (function(){
      const canvas = UI.elements.canvas;
      const ctx = UI.getCanvasContext({ alpha:false });
      let W = canvas.width, H = canvas.height;
      let axisLeft = 64, axisBottom = 28;
      let viewX = axisLeft, viewW = W - axisLeft, viewH = H - axisBottom;
      const offW = 16384;
      let offH = 0;
      const circular = document.createElement('canvas');
      const cctx = circular.getContext('2d', { alpha:false });
      let offWriteX = 0, raf=null, analyserBins=0, byteData=null, lastGoodByteData=null;
      const NONZERO_THRESHOLD=6;

      function recalcSizes(){
        W = canvas.width; H = canvas.height;
        const dpr = window.devicePixelRatio || 1;
        axisLeft = 64;
        axisBottom = 28;
        viewX = axisLeft;
        viewW = Math.max(64, Math.round((canvas.width / (dpr || 1)) - axisLeft));
        viewH = Math.max(40, Math.round((canvas.height / (dpr || 1)) - axisBottom));
        offH = Math.max(8, Math.round(viewH * (dpr || 1)));
        circular.width = offW;
        circular.height = offH;
      }

      recalcSizes();

      function clearLastGood(){ lastGoodByteData = null; try{ window.__spectro_last_good = null; }catch(e){} }
      function clearScreens(){ cctx.fillStyle='#000'; cctx.fillRect(0,0,offW,offH); offWriteX=0; ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height); drawAxes(0,1); }
      function getUserYMaxHz(){ const ui = UI.elements.yMax ? Number(UI.elements.yMax.value) : NaN; if(!Number.isFinite(ui)) return null; return Math.max(0, ui*1000); }

      function drawAxes(curSec, visibleSeconds){
        const dpr = window.devicePixelRatio || 1;
        const vpX = Math.round(viewX * dpr);
        const vpW = Math.round(viewW * dpr);
        const vpH = Math.round(viewH * dpr);
        ctx.fillStyle='#000';
        ctx.fillRect(0,0,Math.round(axisLeft * dpr), vpH);
        ctx.fillRect(0,vpH,canvas.width, Math.round(axisBottom * dpr));
        ctx.strokeStyle='#444';
        ctx.lineWidth = Math.max(1, 1 * dpr);
        ctx.font = `${12 * dpr}px system-ui`;
        ctx.fillStyle='#bbb';
        const audioCtx = Audio.getAudioContext();
        const nyqFromSR = (audioCtx && audioCtx.sampleRate) ? audioCtx.sampleRate/2 : 22050;
        const userMaxHz = getUserYMaxHz();
        const shownMaxHz = (userMaxHz && userMaxHz>0) ? Math.min(userMaxHz, nyqFromSR) : nyqFromSR;
        const ticks=6;
        ctx.textAlign='right';
        for(let i=0;i<=ticks;i++){
          const frac=i/ticks;
          const y=Math.round(frac*vpH);
          const hz=(1-frac)*shownMaxHz;
          const khz=hz/1000;
          ctx.beginPath();
          ctx.moveTo(Math.round((axisLeft-6)*dpr), y);
          ctx.lineTo(Math.round((axisLeft+2)*dpr), y);
          ctx.stroke();
          const label=(Math.abs(Math.round(khz)-khz)<0.001)?Math.round(khz).toString():khz.toFixed(1);
          ctx.fillText(label, Math.round((axisLeft-8)*dpr), y + Math.round(4 * dpr));
        }
        ctx.textAlign='start';
        ctx.fillStyle='#888';
        ctx.fillText('kHz', Math.round(6 * dpr), Math.round(14 * dpr));
        const timeTicks=6;
        for(let i=0;i<=timeTicks;i++){
          const frac=i/timeTicks;
          const x = Math.round((viewX + frac*viewW) * dpr);
          ctx.beginPath();
          ctx.moveTo(x, vpH);
          ctx.lineTo(x, vpH + Math.round(8 * dpr));
          ctx.stroke();
          const tval = (typeof curSec==='number' ? curSec : Audio.getCurrentPosition()) - (1-frac)*visibleSeconds;
          ctx.fillText(tval.toFixed(2), x + Math.round(2 * dpr), vpH + Math.round(16 * dpr));
        }
        ctx.fillStyle='#888';
        ctx.fillText('seconds', Math.round((viewX+6) * dpr), vpH + Math.round(20 * dpr));
      }

      function drawAnnotations(curSec, visibleSeconds){
        if(!GLOBAL_lastParsedAnnotation || !Array.isArray(GLOBAL_lastParsedAnnotation.rows) || GLOBAL_lastParsedAnnotation.rows.length === 0) return;

        const mapStart = UI.elements.annSelectStart ? (UI.elements.annSelectStart.value || '') : '';
        const mapEnd = UI.elements.annSelectEnd ? (UI.elements.annSelectEnd.value || '') : '';
        const mapLow = UI.elements.annSelectLow ? (UI.elements.annSelectLow.value || '') : '';
        const mapHigh = UI.elements.annSelectHigh ? (UI.elements.annSelectHigh.value || '') : '';
        const mapLabel = UI.elements.annSelectLabel ? (UI.elements.annSelectLabel.value || '') : '';
        const boxChecked = UI.elements.boxType ? UI.elements.boxType.checked : true;

        if(!mapStart || !mapEnd) return;
        if(boxChecked && (!mapLow || !mapHigh)) return;

        const audioCtx = Audio.getAudioContext();
        if(!audioCtx) return;
        const nyqFromSR = audioCtx.sampleRate/2;
        const userMaxHz = getUserYMaxHz();
        const shownMaxHz = (userMaxHz && userMaxHz>0) ? Math.min(userMaxHz, nyqFromSR) : nyqFromSR;

        ctx.save();
        const dpr = window.devicePixelRatio || 1;

        GLOBAL_lastParsedAnnotation.rows.forEach((origRow, idx)=>{
          const startRaw = origRow.hasOwnProperty(mapStart) ? origRow[mapStart] : '';
          const endRaw = origRow.hasOwnProperty(mapEnd) ? origRow[mapEnd] : '';
          const parsedStart = parseFloat(startRaw);
          const parsedEnd = parseFloat(endRaw);
          if(!Number.isFinite(parsedStart) || !Number.isFinite(parsedEnd)) return;
          const annStart = parsedStart;
          const annEnd = parsedEnd;

          let annLow = 0;
          let annHigh = 25000;
          if(boxChecked){
            const lowRaw = origRow.hasOwnProperty(mapLow) ? origRow[mapLow] : '';
            const highRaw = origRow.hasOwnProperty(mapHigh) ? origRow[mapHigh] : '';
            const parsedLow = parseFloat(lowRaw);
            const parsedHigh = parseFloat(highRaw);
            if(!Number.isFinite(parsedLow) || !Number.isFinite(parsedHigh)) return;
            annLow = parsedLow;
            annHigh = parsedHigh;
          }

          const displayLabel = mapLabel && origRow.hasOwnProperty(mapLabel) ? String(origRow[mapLabel] || '') : '';

          const annLowClamped = Math.max(0, Math.min(annLow, shownMaxHz));
          const annHighClamped = Math.max(0, Math.min(annHigh, shownMaxHz));
          if(annHighClamped <= annLowClamped) return;
          if(annEnd < curSec - visibleSeconds || annStart > curSec) return;

          const fracStart = 1 - (curSec - annStart) / visibleSeconds;
          const fracEnd = 1 - (curSec - annEnd) / visibleSeconds;
          const x1 = viewX + fracStart*viewW;
          const x2 = viewX + fracEnd*viewW;
          const yHighFrac = 1 - (annHighClamped / shownMaxHz);
          const yLowFrac = 1 - (annLowClamped / shownMaxHz);
          const y1 = yHighFrac * viewH;
          const y2 = yLowFrac * viewH;
          const rx = Math.max(viewX, Math.min(viewX+viewW, Math.min(x1,x2)));
          const rw = Math.max(0, Math.min(viewX+viewW, Math.max(x1,x2)) - rx);
          const ry = Math.max(0, Math.min(viewH, Math.min(y1,y2)));
          const rh = Math.max(0, Math.min(viewH, Math.max(y1,y2)) - ry);
          if(rw<=0||rh<=0) return;

          const px = Math.round(rx * dpr);
          const py = Math.round(ry * dpr);
          const pw = Math.round(rw * dpr);
          const ph = Math.round(rh * dpr);

          if(__spectro_currentAnnotationIndex === idx){
            ctx.fillStyle='rgba(78,161,255,0.22)';
            ctx.strokeStyle='rgba(78,161,255,0.95)';
            const dashSize = Math.max(2, Math.round(6 * dpr));
            const gapSize = Math.max(2, Math.round(6 * dpr));
            ctx.setLineDash([dashSize, gapSize]);
            ctx.lineWidth = Math.max(1.5, 1.5 * dpr);
            ctx.fillRect(px, py, pw, ph);
            ctx.strokeRect(px + 0.5, py + 0.5, Math.max(0, pw-1), Math.max(0, ph-1));
            ctx.setLineDash([]);
            ctx.font = `${12 * dpr}px system-ui`;
            const labelText = String(idx + 1) + (displayLabel ? ' | ' + displayLabel : '');
            ctx.fillStyle = '#ffd400';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            const badgeX = px + 4;
            const badgeH = Math.round(16 * dpr) + 4;
            ctx.fillText(labelText, badgeX + Math.round(4 * dpr), Math.max(py - badgeH - 4, 2) + Math.round(badgeH/2));
          } else {
            ctx.fillStyle='rgba(255,255,0,0.14)';
            ctx.strokeStyle='rgba(255,255,0,0.8)';
            ctx.lineWidth = Math.max(1, 1 * dpr);
            ctx.fillRect(px, py, pw, ph);
            ctx.strokeRect(px + 0.5, py + 0.5, Math.max(0, pw-1), Math.max(0, ph-1));
            if(displayLabel){
              const labelText = String(idx + 1) + ' | ' + displayLabel;
              ctx.font = `${11 * dpr}px system-ui`;
              ctx.fillStyle = '#ffd400';
              ctx.textAlign = 'left';
              ctx.textBaseline = 'middle';
              const badgeX = px + 4;
              const badgeH = Math.round(14 * dpr) + 4;
              ctx.fillText(labelText, badgeX + Math.round(4 * dpr), Math.max(py - badgeH - 4, 2) + Math.round(badgeH/2));
            }
          }
        });

        ctx.restore();
      }

      function startDrawLoop(paletteName='heat'){
        stopDrawLoop();
        const analyser = Audio.getAnalyser(true);
        if(!analyser) return;
        analyserBins = analyser.frequencyBinCount;
        byteData = new Uint8Array(analyserBins);
        lastGoodByteData=null;
        try{ window.__spectro_last_good=null; }catch(e){}
        function frame(){
          try{ analyser.getByteFrequencyData(byteData); }catch(e){ stopDrawLoop(); return; }
          let anyNonZero=false;
          for(let i=0;i<byteData.length;i++){ if(byteData[i]>NONZERO_THRESHOLD){ anyNonZero=true; break; } }
          if(anyNonZero){ lastGoodByteData = new Uint8Array(byteData); try{ window.__spectro_last_good = lastGoodByteData; }catch(e){} }
          const buf = Audio.getBuffer && Audio.getBuffer();
          const pos = Audio.getCurrentPosition();
          const playbackEndedFlag = !!window.__spectro_playback_ended;
          if(playbackEndedFlag || (buf && typeof buf.duration==='number' && pos >= Math.max(0, buf.duration - 0.05))){
            const finalBytes = lastGoodByteData || byteData;
            const speed = Math.max(1, Number(UI.elements.speed.value)||1);
            for(let s=0;s<speed;s++) drawSpectrogramColumnFromBytes(finalBytes, UI.elements.palette.value);
            blitVisible();
            try{
              const secondsPerPixel = 1 / (Math.max(1, Number(UI.elements.speed.value))*60);
              const visibleSeconds = viewW * secondsPerPixel;
              const curSec = (buf && buf.duration) ? Math.max(0, buf.duration - Math.min(visibleSeconds * 0.25, 0.2)) : pos;
              drawAxes(curSec, visibleSeconds);
              drawAnnotations(curSec, visibleSeconds);
              UI.setPositionText(curSec);
            }catch(e){}
            stopDrawLoop();
            try{ window.__spectro_playback_ended=false; }catch(e){}
            setCanvasWidthControlsEnabled(true);
            if(__spectro_inSnippetPlayback){
              __spectro_inSnippetPlayback = false;
              disableZoomAndYmax(false);
            }
            return;
          }

          const speed = Math.max(1, Number(UI.elements.speed.value)||1);
          for(let s=0;s<speed;s++){
            const bins = byteData.length;
            const audioCtx = Audio.getAudioContext();
            const nyqFromSR = (audioCtx && audioCtx.sampleRate) ? audioCtx.sampleRate/2 : 22050;
            const userMaxHz = getUserYMaxHz();
            const shownMaxHz = (userMaxHz && userMaxHz>0) ? Math.min(userMaxHz, nyqFromSR) : nyqFromSR;
            const indexMax = Math.max(1, Math.min(bins-1, Math.round((shownMaxHz/nyqFromSR)*(bins-1))));
            const dpr = window.devicePixelRatio || 1;
            for(let y=0;y<offH;y++){
              const frac = 1 - (y / (offH - 1));
              const idx = Math.round(frac * indexMax);
              const v = byteData[idx]||0;
              cctx.fillStyle = paletteColor(UI.elements.palette.value, v);
              cctx.fillRect(offWriteX, y, 1, 1);
            }
            offWriteX = (offWriteX + 1) % offW;
          }

          blitVisible();

          const secondsPerPixel = 1 / (Math.max(1, Number(UI.elements.speed.value))*60);
          const visibleSeconds = viewW * secondsPerPixel;
          const curSec = Audio.getCurrentPosition();
          drawAxes(curSec, visibleSeconds);
          drawAnnotations(curSec, visibleSeconds);
          UI.setPositionText(curSec);
          raf = requestAnimationFrame(frame);
        }
        raf = requestAnimationFrame(frame);
      }

      function stopDrawLoop(){ if(raf) cancelAnimationFrame(raf); raf=null; }

      function drawSpectrogramColumnFromBytes(bytes, paletteName){
        if(!bytes || !bytes.length) return;
        const bins = bytes.length;
        const audioCtx = Audio.getAudioContext();
        const nyqFromSR = (audioCtx && audioCtx.sampleRate) ? audioCtx.sampleRate/2 : 22050;
        const userMaxHz = UI.elements.yMax ? Number(UI.elements.yMax.value) : NaN;
        const shownMaxHz = (Number.isFinite(userMaxHz) && userMaxHz>0) ? Math.min(userMaxHz*1000, nyqFromSR) : nyqFromSR;
        const indexMax = Math.max(1, Math.min(bins-1, Math.round((shownMaxHz/nyqFromSR)*(bins-1))));
        for(let y=0;y<offH;y++){
          const frac = 1 - (y / (offH - 1));
          const idx=Math.round(frac*indexMax);
          const v = bytes[idx]||0;
          cctx.fillStyle = paletteColor(paletteName, v);
          cctx.fillRect(offWriteX, y, 1, 1);
        }
        offWriteX = (offWriteX + 1) % offW;
      }

      function blitVisible(){
        const dpr = window.devicePixelRatio || 1;
        const visibleWidthInOff = Math.max(4, Math.round(viewW));
        const rightEdge = (offWriteX - 1 + offW) % offW;
        const leftEdge = (rightEdge - visibleWidthInOff + 1 + offW*1000) % offW;
        const vpX = Math.round(viewX * dpr), vpY = 0, vpW = Math.round(viewW * dpr), vpH = Math.round(viewH * dpr);
        ctx.fillStyle='#000';
        ctx.fillRect(vpX, vpY, vpW, vpH);

        if(leftEdge + visibleWidthInOff <= offW){
          ctx.drawImage(circular, leftEdge, 0, visibleWidthInOff, offH, vpX, vpY, vpW, vpH);
        } else {
          const firstW = offW - leftEdge;
          const secondW = visibleWidthInOff - firstW;
          const firstPx = Math.round(firstW * (vpW / visibleWidthInOff));
          const secondPx = vpW - firstPx;
          ctx.drawImage(circular, leftEdge, 0, firstW, offH, vpX, vpY, firstPx, vpH);
          ctx.drawImage(circular, 0, 0, secondW, offH, vpX + firstPx, vpY, secondPx, vpH);
        }
      }

      function insertFinalColumns(bytes, count, paletteName){
        if(!bytes || !bytes.length) return;
        const c = Math.max(1, Math.floor(count||1));
        const bins = bytes.length;
        const audioCtx = Audio.getAudioContext();
        const nyqFromSR = (audioCtx && audioCtx.sampleRate) ? audioCtx.sampleRate/2 : 22050;
        const userMaxHz = UI.elements.yMax ? Number(UI.elements.yMax.value) : NaN;
        const shownMaxHz = (Number.isFinite(userMaxHz) && userMaxHz>0) ? Math.min(userMaxHz*1000, nyqFromSR) : nyqFromSR;
        const indexMax = Math.max(1, Math.min(bins-1, Math.round((shownMaxHz/nyqFromSR)*(bins-1))));
        const pal = paletteName || (UI.elements.palette?UI.elements.palette.value:'heat');
        for(let i=0;i<c;i++){
          for(let y=0;y<offH;y++){
            const frac = 1 - (y / (offH - 1));
            const idx = Math.round(frac * indexMax);
            const v = bytes[idx] || 0;
            cctx.fillStyle = paletteColor(pal, v);
            cctx.fillRect(offWriteX, y, 1, 1);
          }
          offWriteX = (offWriteX + 1) % offW;
        }
        try{ window.__spectro_last_good = bytes; }catch(e){}
      }

      return {
        clearScreens,
        startDrawLoop,
        stopDrawLoop,
        renderFinalFrame:function(){},
        clearLastGood,
        insertFinalColumns,
        onResize: function(){
          recalcSizes();
          try{ cctx.fillStyle = '#000'; cctx.fillRect(0,0,circular.width,circular.height); }catch(e){}
          offWriteX = 0;
          try{ ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height); }catch(e){}
        }
      };
    })();

    const AnnotationsInternal = (function(){
      let anns = [];
      return {
        set(a){ anns = (a||[]).map((_, idx) => ({ sr: idx + 1, rowIndex: idx })); },
        get(){ return anns.slice(); },
        clear(){ anns=[]; }
      };
    })();

    function initColumnResizers(table){
      const ths = Array.from(table.querySelectorAll('thead th'));
      ths.forEach((th, index)=>{
        const resizer = th.querySelector('.col-resizer');
        if(!resizer) return;
        let startX, startWidth, colIndex=index;
        function onPointerDown(e){
          e.preventDefault();
          startX = e.clientX;
          startWidth = th.getBoundingClientRect().width;
          document.addEventListener('pointermove', onPointerMove);
          document.addEventListener('pointerup', onPointerUp, { once:true });
          try{ resizer.setPointerCapture && resizer.setPointerCapture(e.pointerId); }catch(e){}
        }
        function onPointerMove(e){
          const dx = e.clientX - startX;
          const newWidth = Math.max(20, Math.round(startWidth + dx));
          th.style.width = newWidth + 'px';
          th.style.minWidth = newWidth + 'px';
          th.style.maxWidth = newWidth + 'px';
          const rows = table.querySelectorAll('tbody tr');
          rows.forEach(r=>{
            const cell = r.children[colIndex];
            if(cell){
              cell.style.width = newWidth + 'px';
              cell.style.minWidth = '20px';
              cell.style.maxWidth = newWidth + 'px';
              cell.style.overflow = 'hidden';
              cell.style.textOverflow = 'ellipsis';
              cell.style.whiteSpace = 'nowrap';
            }
          });
        }
        function onPointerUp(){ document.removeEventListener('pointermove', onPointerMove); }
        resizer.addEventListener('pointerdown', onPointerDown);
      });
    }

    function setCanvasWidthControlsEnabled(enabled){
      try{
        const preset = UI.elements.canvasWidthPreset;
        const custom = UI.elements.canvasWidthCustom;
        if(preset) preset.disabled = !enabled;
        if(custom) custom.disabled = !enabled;
        if(preset){
          if(!enabled) preset.classList.add('disabled'); else preset.classList.remove('disabled');
        }
        if(custom){
          if(!enabled) custom.classList.add('disabled'); else custom.classList.remove('disabled');
        }
      }catch(e){ console.error('setCanvasWidthControlsEnabled', e); }
    }

    function disableZoomAndYmax(disable){
      try{
        const speed = UI.elements.speed;
        const yMax = UI.elements.yMax;
        if(speed) speed.disabled = !!disable;
        if(yMax) yMax.disabled = !!disable;
        if(speed) { if(disable) speed.classList.add('disabled'); else speed.classList.remove('disabled'); }
        if(yMax) { if(disable) yMax.classList.add('disabled'); else yMax.classList.remove('disabled'); }
      }catch(e){ console.error('disableZoomAndYmax', e); }
    }

    function highlightTableRow(idx) {
      const table = UI.elements.annTable;
      if(!table) return;
      Array.from(table.querySelectorAll('tbody tr')).forEach((tr, i)=>{
        if(i === idx) tr.classList.add('annotation-selected');
        else tr.classList.remove('annotation-selected');
      });
    }

    function updatePlayCheckboxStates(){
      const table = UI.elements.annTable;
      if(!table) return;
      Array.from(table.querySelectorAll('tbody tr')).forEach((tr, i)=>{
        const chk = tr.querySelector('td input.play-checkbox');
        if(!chk) return;
        if(i === __spectro_currentAnnotationIndex){
          chk.checked = true;
          tr.classList.add('annotation-selected');
        } else {
          if(!__spectro_inSnippetPlayback){
            tr.classList.remove('annotation-selected');
          } else {
            chk.checked = false;
            tr.classList.remove('annotation-selected');
          }
        }
      });
    }

    function stopAllPlaybackAndClear(){
      try {
        if(__spectro_annotationStopTimer){ clearTimeout(__spectro_annotationStopTimer); __spectro_annotationStopTimer = null; }
        try{ Audio.stopPlayback(); }catch(e){}
        try{ Draw.stopDrawLoop(); }catch(e){}
        try{ Draw.clearLastGood(); }catch(e){}
        try{ Draw.clearScreens(); }catch(e){}
      } catch(err) { console.error('stopAllPlaybackAndClear', err); }
      __spectro_inSnippetPlayback = false;
      disableZoomAndYmax(false);
      updatePlayCheckboxStates();
    }

    function clearSnippetPlayback(){
      if(__spectro_annotationStopTimer){ clearTimeout(__spectro_annotationStopTimer); __spectro_annotationStopTimer = null; }
      try{ Audio.stopPlayback(); }catch(e){}
      try{ Draw.stopDrawLoop(); }catch(e){}
      __spectro_currentAnnotationIndex = -1;
      __spectro_inSnippetPlayback = false;
      disableZoomAndYmax(false);
      updatePlayCheckboxStates();
    }

    function prepareForRowSwitchSafe(){
      if(__spectro_annotationStopTimer){ clearTimeout(__spectro_annotationStopTimer); __spectro_annotationStopTimer = null; }
      try{ Audio.stopPlaybackSilent(); }catch(e){ try{ Audio.stopPlayback(); }catch(e){} }
      try{ Draw.stopDrawLoop(); }catch(e){}
      try{ Draw.clearLastGood(); }catch(e){}
      updatePlayCheckboxStates();
    }

    function startRowSwitchPlayback(rowIdx){
      if(!GLOBAL_lastParsedAnnotation || !Array.isArray(GLOBAL_lastParsedAnnotation.rows)) return;
      if(rowIdx < 0 || rowIdx >= GLOBAL_lastParsedAnnotation.rows.length) return;
      prepareForRowSwitchSafe();
      setTimeout(()=> {
        playAnnotation(rowIdx);
      }, 60);
    }

    async function playAnnotation(rowIdx) {
      if(!GLOBAL_lastParsedAnnotation || !Array.isArray(GLOBAL_lastParsedAnnotation.rows)) return;
      const rows = GLOBAL_lastParsedAnnotation.rows;
      if(rowIdx < 0 || rowIdx >= rows.length) return;

      const startCol = UI.elements.annSelectStart ? UI.elements.annSelectStart.value : '';
      const endCol = UI.elements.annSelectEnd ? UI.elements.annSelectEnd.value : '';
      if(!startCol || !endCol) return;

      const row = rows[rowIdx];
      const rawStart = row[startCol];
      const rawEnd = row[endCol];
      const startSec = Number(parseFloat(rawStart));
      const endSec = Number(parseFloat(rawEnd));
      if(!Number.isFinite(startSec) || !Number.isFinite(endSec) || endSec <= startSec) return;

      const playFrom = Math.max(0, startSec - 1.0);
      const stopAt = endSec + 1.0;

      const buf = Audio.getBuffer();
      if(!buf){
        alert('Load a sound file first.');
        return;
      }

      __spectro_currentAnnotationIndex = rowIdx;
      __spectro_inSnippetPlayback = true;
      highlightTableRow(rowIdx);
      const table = UI.elements.annTable;
      Array.from(table.querySelectorAll('input.play-checkbox')).forEach(ch=>{
        ch.checked = Number(ch.dataset.rowIndex) === rowIdx;
      });

      try {
        disableZoomAndYmax(true);
        Audio.startPlayback(playFrom);
        Draw.startDrawLoop(UI.elements.palette.value);
        if(__spectro_annotationStopTimer){ clearTimeout(__spectro_annotationStopTimer); __spectro_annotationStopTimer = null; }
        const delayMs = Math.max(0, Math.round((stopAt - playFrom) * 1000));
        __spectro_annotationStopTimer = setTimeout(()=>{
          try{ Audio.pausePlayback(); }catch(e){ console.error(e); }
          __spectro_inSnippetPlayback = false;
          disableZoomAndYmax(false);
          updatePlayCheckboxStates();
          __spectro_annotationStopTimer = null;
        }, delayMs);
      } catch(e) {
        console.error('playAnnotation failed', e);
        __spectro_inSnippetPlayback = false;
        disableZoomAndYmax(false);
        updatePlayCheckboxStates();
      }
    }

    (function wireApp(){
      const savedSelections = { start:'', end:'', low:'', high:'', label:'' };

      UI.onMappingChange(()=>{
        ['annSelectStart','annSelectEnd','annSelectLow','annSelectHigh','annSelectLabel'].forEach(id=>{
          const el = UI.elements[id];
          if(el) {
            const key = id.replace('annSelect','').toLowerCase();
            savedSelections[key] = el.value || '';
          }
        });
        if(UI.elements.boxType.checked){
          UI.elements.annSelectLow.disabled = false;
          UI.elements.annSelectHigh.disabled = false;
          UI.elements.annSelectLow.classList.remove('disabled');
          UI.elements.annSelectHigh.classList.remove('disabled');
        } else {
          UI.elements.annSelectLow.disabled = true;
          UI.elements.annSelectHigh.disabled = true;
          UI.elements.annSelectLow.classList.add('disabled');
          UI.elements.annSelectHigh.classList.add('disabled');
        }
      });

      onSaveReviewRequest = function(){
        try{
          if(!GLOBAL_lastParsedAnnotation || !GLOBAL_lastParsedAnnotation.rows) { alert('No parsed annotation available to save.'); return; }
          const table = UI.elements.annTable;
          const bodyRows = Array.from(table.querySelectorAll('tbody tr'));
          if(!bodyRows.length){ alert('No rows to save.'); return; }

          const originalHeaders = GLOBAL_lastParsedAnnotation.headers.slice();
          const reviewedHeaders = originalHeaders.concat(['Reviewed OK','Rejection remarks']);
          const lines = [];
          lines.push(reviewedHeaders.join('\t'));

          bodyRows.forEach((tr, idx)=>{
            const originalRow = GLOBAL_lastParsedAnnotation.rows[idx] || {};
            const rowVals = originalHeaders.map(h => {
              const v = originalRow.hasOwnProperty(h) ? originalRow[h] : '';
              return String(v).replace(/\t/g,' ').replace(/\r?\n/g,' ');
            });

            // Correct logic: Reviewed OK column corresponds to the reviewed checkbox (second checkbox in the row)
            const allCheckboxes = tr.querySelectorAll('input[type="checkbox"]');
            const reviewedCellChk = (allCheckboxes && allCheckboxes.length > 1) ? allCheckboxes[1] : (allCheckboxes && allCheckboxes[0]) ? allCheckboxes[0] : null;
            const reviewedOK = (reviewedCellChk && reviewedCellChk.checked) ? 'OK' : 'Not OK';

            const remarksInput = tr.querySelector('input[type="text"]');
            const remarksVal = remarksInput ? String(remarksInput.value || '').replace(/\t/g,' ').replace(/\r?\n/g,' ') : '';
            rowVals.push(reviewedOK, remarksVal);
            lines.push(rowVals.join('\t'));
          });

          const srcFileName = lastAnnotationFilename || 'annotations';
          const dot = srcFileName.lastIndexOf('.');
          const base = dot>0 ? srcFileName.substring(0,dot) : srcFileName;
          const ext = dot>0 ? srcFileName.substring(dot) : '.txt';
          const outName = `${base}-Reviewed${ext}`;
          const blob = new Blob([lines.join('\n')], { type:'text/tab-separated-values;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = outName;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(()=> URL.revokeObjectURL(url), 5000);
        }catch(e){
          console.error('Save review failed', e);
          alert('Save review failed. See console for details.');
        }
      };

      UI.onFile(async (e)=>{
        const f = e.target.files && e.target.files[0]; if(!f) return;
        try{
          Audio.stopPlayback();
          Draw.stopDrawLoop();
          try { if (UI.elements.annFile) UI.elements.annFile.value = ''; } catch(e){}
          AnnotationsInternal.clear();
          const raw = await f.arrayBuffer();
          await Audio.loadArrayBuffer(raw);
          try { window.__spectro_playback_ended = false; window.__spectro_paused_time = null; } catch(e){}
          if (UI.elements.yMaxLabel && UI.elements.yMax) UI.elements.yMaxLabel.textContent = Number(UI.elements.yMax.value).toFixed(1);
          UI.setPlayEnabled(true);
          UI.setPositionText(0);
          try{ Draw.onResize(); Draw.clearScreens(); }catch(e){}
        }catch(err){
          console.error('Failed loading audio', err);
          UI.setPlayEnabled(false);
          alert('Failed to decode audio. Try a WAV/MP3 with PCM/CBR.');
        }
      });

      UI.onAnnFile(async (e)=>{
        const f = e.target.files && e.target.files[0]; if(!f) return;
        try{
          const text = await f.text();
          const parsed = Annotations.parseAnnotationText(text);
          GLOBAL_lastParsedAnnotation = parsed;
          lastAnnotationFilename = f.name || '';
          try{ Draw.onResize(); Draw.clearScreens(); }catch(e){}

          const headers = parsed.headers && parsed.headers.length ? parsed.headers : Object.keys(parsed.rows[0] || {});
          UI.elements.annSelectRow.style.display = 'flex';
          UI.populateAnnotationSelects(headers);

          if(savedSelections.start && headers.includes(savedSelections.start)) UI.elements.annSelectStart.value = savedSelections.start;
          if(savedSelections.end && headers.includes(savedSelections.end)) UI.elements.annSelectEnd.value = savedSelections.end;
          if(savedSelections.low && headers.includes(savedSelections.low)) UI.elements.annSelectLow.value = savedSelections.low;
          if(savedSelections.high && headers.includes(savedSelections.high)) UI.elements.annSelectHigh.value = savedSelections.high;
          if(savedSelections.label && headers.includes(savedSelections.label)) UI.elements.annSelectLabel.value = savedSelections.label;

          UI.renderAnnotationTableFull(headers, parsed.rows || []);
          AnnotationsInternal.set(parsed.rows || []);
        }catch(err){
          console.error('Annotation parse failed', err);
          alert('Failed to parse annotation file. Ensure it is TSV/CSV with the required headers.');
        }
      });

      UI.onPlayToggle(()=>{
        if(!Audio.isPlayingNow()){
          try{
            const resumeAt = Audio.getCurrentPosition();
            Audio.startPlayback(resumeAt);
            Draw.startDrawLoop(UI.elements.palette.value);
          }catch(e){
            console.error('startPlayback failed', e);
            alert('Playback failed. Click anywhere on the page first to unlock audio and try again.');
          }
        } else {
          try{ Audio.pausePlayback(); }catch(e){}
          try{ Draw.stopDrawLoop(); }catch(e){}
        }
      });

      UI.onPlayFromStart(()=>{
        try {
          try { if (UI.elements.playFromStart) UI.elements.playFromStart.disabled = true; } catch(e){}
          prepareForRowSwitchSafe();
          setTimeout(()=>{
            try { window.__spectro_paused_time = null; window.__spectro_playback_ended = false; } catch(e){}
            Audio.startPlayback(0);
            Draw.startDrawLoop(UI.elements.palette.value);
          }, 60);
        } catch(err){
          console.error('Play from start failed', err);
          try { if (UI.elements.playFromStart) UI.elements.playFromStart.disabled = false; } catch(e){}
          alert('Failed to start playback from beginning. Ensure an audio file is loaded and click anywhere on the page to unlock audio if needed.');
        }
      });

      UI.onStop(()=>{
        Audio.stopPlayback();
        Draw.stopDrawLoop();
        try { Draw.renderFinalFrame({ naturalEnd: true }); } catch(e){ Draw.clearScreens(); }
        __spectro_inSnippetPlayback = false;
        disableZoomAndYmax(false);
        updatePlayCheckboxStates();
      });

      UI.onFFT(async ()=>{
        const newFFT = Number(UI.elements.fft.value) || 2048;
        const actx = Audio.getAudioContext();
        if (!actx) {
          try { Audio.createAnalyser(); } catch(e){}
          const a = Audio.getAnalyser(false);
          if (a) a.fftSize = newFFT;
          return;
        }
        let currentAnalyser = Audio.getAnalyser(false);
        if (currentAnalyser) {
          try { currentAnalyser.fftSize = newFFT; } catch(e){ currentAnalyser = null; }
        }
        if (!currentAnalyser) {
          try {
            const old = Audio.getAnalyser(false);
            try { if (old) old.disconnect(); } catch(e){}
            try { Audio.createAnalyser(); } catch(e){}
            const created = Audio.getAnalyser(false);
            if (created) created.fftSize = newFFT;
          } catch(e){ console.warn('FFT rewire failed', e); }
        }
        try { Draw.stopDrawLoop(); Draw.startDrawLoop(UI.elements.palette.value); } catch(e){}
      });

      UI.onPalette(()=>{
        if(!Audio.isPlayingNow()){
          Draw.clearScreens();
          Draw.startDrawLoop(UI.elements.palette.value);
          Draw.stopDrawLoop();
        }
      });

      UI.onYMax(()=>{
        try {
          if (!Audio.isPlayingNow()) {
            Draw.clearScreens();
            try { Draw.startDrawLoop(UI.elements.palette.value); Draw.stopDrawLoop(); } catch(e){}
            try { Draw.renderFinalFrame(); } catch(e){}
          }
        } catch(e){}
      });

      Audio.hooks.onEnded = function(){
        try { Draw.stopDrawLoop(); } catch(e){}
        try { Draw.renderFinalFrame({ naturalEnd: true }); } catch(e){}
        setCanvasWidthControlsEnabled(true);
        __spectro_inSnippetPlayback = false;
        disableZoomAndYmax(false);
        updatePlayCheckboxStates();
      };

      (function canvasWidthControls(){
        const presetEl = UI.elements.canvasWidthPreset;
        const customEl = UI.elements.canvasWidthCustom;
        const viewer = document.getElementById('viewer');
        const canvas = document.getElementById('canvas');
        const DPR = () => window.devicePixelRatio || 1;
        const MIN_CSS = 300;
        const MAX_CSS = 8192;
        function applyCanvasWidth(request){
          let cssWidth;
          if(request === '100%') {
            cssWidth = Math.max(MIN_CSS, Math.floor(viewer.clientWidth));
          } else {
            cssWidth = Number(request) || Math.max(MIN_CSS, Math.floor(viewer.clientWidth));
          }
          cssWidth = Math.max(MIN_CSS, Math.min(MAX_CSS, cssWidth));
          const computed = canvas.getBoundingClientRect();
          const cssHeight = Math.max(80, Math.round(computed.height));
          canvas.style.width = cssWidth + 'px';
          canvas.style.height = cssHeight + 'px';
          canvas.width = Math.round(cssWidth * DPR());
          canvas.height = Math.round(cssHeight * DPR());
          UI.setCanvasWidthInfo(`${cssWidth}px (${canvas.width}px DPR)`);
          try{ Draw.onResize(); }catch(e){}
          try{ Draw.clearScreens(); }catch(e){}
          try{
            if (Audio.isPlayingNow && Audio.isPlayingNow()) {
              try{ Draw.startDrawLoop(UI.elements.palette.value); }catch(e){}
            } else {
              try{ Draw.startDrawLoop(UI.elements.palette.value); Draw.stopDrawLoop(); }catch(e){}
            }
          }catch(e){}
        }
        if(presetEl){
          presetEl.addEventListener('change', (ev)=>{
            const v = ev.target.value;
            if(v === 'custom'){ customEl.style.display = 'inline-block'; customEl.focus(); }
            else { customEl.style.display = 'none'; applyCanvasWidth(v); }
          });
        }
        if(customEl){
          customEl.addEventListener('input', (ev)=> {
            const v = Number(ev.target.value);
            if(Number.isFinite(v) && v >= MIN_CSS) applyCanvasWidth(v);
          });
        }
        try{
          const viewerW = document.getElementById('viewer').clientWidth || window.innerWidth;
          if(viewerW > 1400){
            if(presetEl) presetEl.value = '100%';
            applyCanvasWidth('100%');
          } else {
            const initial = presetEl ? presetEl.value : 1400;
            applyCanvasWidth(initial);
          }
        }catch(e){}
        let resizeTimer = null;
        window.addEventListener('resize', ()=>{
          if(presetEl && presetEl.value === '100%'){
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(()=> applyCanvasWidth('100%'), 150);
          }
        });
      })();

      UI.setPlayEnabled(false);
      UI.setStopEnabled(false);
      try{ Draw.onResize(); Draw.clearScreens(); }catch(e){}
      setCanvasWidthControlsEnabled(true);

      document.addEventListener('click', function resumeOnClick(){
        try{
          const actx = Audio.getAudioContext();
          if(actx && actx.state === 'suspended'){ actx.resume().catch(()=>{}); }
        }catch(e){}
        document.removeEventListener('click', resumeOnClick);
      });
    })();

  })();
  </script>
</body>
</html>